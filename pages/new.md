---
title: KISS
---

An independent Linux® distribution with a focus on simplicity and the concept of "less is more". The distribution currently targets the x86-64 architecture and the English language.

Some prior knowledge of Linux (*or other UNIXY systems*) is required however, those with the capacity, the drive and the willingness to learn will see KISS as a great place to start.


## Table of Contents

<!-- vim-markdown-toc GFM -->

* [Overview](#overview)
* [Aims](#aims)
* [Philosophy](#philosophy)
    * [Simplicity](#simplicity)
* [Roadmap](#roadmap)
* [Development Team](#development-team)
* [Package System](#package-system)
    * [Directory Structure](#directory-structure)
    * [Benefits to this System](#benefits-to-this-system)
    * [`build`](#build)
    * [`depends`](#depends)
    * [`sources`](#sources)
    * [`version`](#version)
    * [`checksums`](#checksums)
    * [`manifest`](#manifest)
    * [`post-install`](#post-install)
    * [`nostrip`](#nostrip)
    * [`patches/*`](#patches)
    * [`files/*`](#files)
* [Package Manager](#package-manager)
* [Further Reading](#further-reading)

<!-- vim-markdown-toc -->

## Overview

- Independent (*not based on another distribution*).
- Easily parseable plain-text package system.
- Tiny package manager written in 500 LOC (*excluding comments and blank lines*).
- All shell code passes `shellcheck`.

**Software Choices**

- libc: [musl](https://wiki.musl-libc.org/).
- coreutils: [busybox](https://busybox.net/).
- init: `busybox init`.
- services: `busybox runit`, `busybox sysvinit` or roll your own.

**NOTE**: The `init` and service manager can be swapped out to use whatever you desire.


## Aims

- Able to be maintained by only 1-2 people.
- Be a simple Linux system.
- Provide a simple packaging system.
- Provide small and curated official repositories.


## Philosophy

### Simplicity

KISS follows the KISS principle (*Keep it Simple Stupid*). Stupid in this context refers to the knowledge required to develop and maintain the distribution.

The word "simple" has many different interpretations in this context, is the distribution simple to use, simple to develop or simple in its implementation? Further the phrase "simple to use" differs depending on the person.

Users with a prior knowledge of Linux and basic programming skills will find KISS simple in all three examples given above. A user without prior knowledge may see KISS as the exact opposite.

Making things "easy" through GUI configuration tools, a next-next-next installation process and other niceties cause the system to become more and more complex.

The more code and documentation you add to a project, the more time it takes to maintain it and the risk of things going awry rises.

KISS does away with these things which gives additional responsibility to the user while at the same time giving them increased flexibility and in the end a simpler system.


## Roadmap

KISS is nearing a **1.0** release and is already fully functional! The issues below relate more to overall polish, installation and documentation.

**KISS 1.0**

- Finalize documentation.
    - Website.
    - Repository creation.
    - Package manager.
    - Package format.
- Packages.
    - Split `mesa` into separate driver packages.
    - Package remaining `xf86-video-*` drivers.
- Simplify installation.
    - Finish `kiss-initramfs`.

**The Future**

- Website.
    - Add a blog to the website.
- Distribution.
    - Add support for encrypted drives.
- Package Manager.
    - Add a `USE_FLAGS` type feature.
    - Add an "alternatives" system.


## Development Team

KISS is developed by the following people.

**Dylan Araps ([dylanaraps](https://github.com/dylanaraps))**

- Creator of KISS.
- Creator of [neofetch](https://github.com/dylanaraps/neofetch), [pywal](https://github.com/dylanaraps/pywal), [fff](https://github.com/dylanaraps/fff) and the [Pure Bash Bible](https://github.com/dylanaraps/pure-bash-bible).

**Muhammad Herdiansyah ([KONIMEX](https://github.com/konimex))**

- Developer.


## Package System

The package system that KISS employs is based around the concept of easily parseable plain-text files (*separated by lines and spaces*). This format allows you to effortlessly interface with the package system using any programming language or just basic UNIX tools.


### Directory Structure

```sh
zlib/            # Package name.
├─ build         # Build script (must be executable).
├─ depends       # Dependencies (usually required).
├─ sources       # Remote and local sources.
├─ version       # Package version.
┘

# Files generated by the package manager.
├─ checksums     # Checksums for the source files.
├─ manifest      # Tracked files.
┘

# Optional files.
├─ post-install  # Post-install script (must be executable).
├─ nostrip       # Don't strip binaries for this package (empty file).
├─ patches/*     # Directory to store patches.
├─ files/*       # Directory to misc files.
┘
```

### Benefits to this System

**No need to `source` (`eval`) the build script**

All distribution package build tools written in the shell which use an additional shell script full of variables, arrays and functions actually `eval` the latter script into the build tool's "namespace".

In the shell, using `source` or `.` is actually no different from using `eval`. Any code run using `source`/`.` is executed in the same running shell (*and can modify the build tool itself*).

In KISS the build script is executed as if it were any other executable file, essentially just a `./build`. The build script has no access to the internals of the package manager.

**Build scripts are language agnostic**

The above benefit also allows build scripts to be written in whatever programming language you see fit as they're run like a regular executable!

**Metadata files are simple to parse in any language**

The metadata files are separated by lines and spaces and can easily be parsed using whatever language or tools you wish. This makes interfacing with everything really easy!

**The repository files double as an installed package's database entry**

On a package install, the repository files listed above (in "structure") are all installed to `/var/db/kiss/installed` and act as database entries. This allows your local installed package database to double as a local package repository!

The package manager will interface with it when no matching packages are found in a repository. This allows you to rebuild packages which exist in no repository but are installed on your machine!

### `build`

The `build` file should contain all of the steps necessary to patch, configure make and install (*`make install` in this context*) the package.

The script is language agnostic and the only requirement is that it be executable. On execution the script will start in the directory of the package's source (*there's no need to change the working directory*).

The script is also given a single argument (*equivalent to `script arg`*), this argument contains the path where the script should install the compiled files. Everything in the path is added to the package tarball and later installed to the system.

**Example `build` file.**

```
#!/bin/sh -e

./configure \
    --prefix=/usr

make
make DESTDIR="$1" install
```

### `depends`

The `depends` file should contain any other packages the package depends on to function correctly. Each dependency should be listed one per line and an optional second field allows you to specify whether the dependency is needed for the build or at runtime.

**Example `depends` file.**

```
# Comments are also supported.
perl make
zlib
```

### `sources`

The `sources` file should contain all remote and local files the package needs to be built. This includes the source, patches and any other miscellaneous files which may be needed.

Each source should be listed one per line and an optional second field allows you to specify an extraction directory for the source. The extraction directory is relative to the build directory.

**Example `sources` file.**

```
https://roy.marples.name/downloads/dhcpcd/dhcpcd-8.0.2.tar.xz
files/dhcpcd.run
```

**Example `sources` file with optional fields.**

```
https://gcc.gnu.org/pub/gcc/releases/gcc-9.1.0/gcc-9.1.0.tar.xz gcc
https://gmplib.org/download/gmp/gmp-6.1.2.tar.xz gcc/gmp
http://www.mpfr.org/mpfr-4.0.2/mpfr-4.0.2.tar.xz gcc/mpfr
https://ftp.gnu.org/gnu/mpc/mpc-1.1.0.tar.gz gcc/mpc
files/c99
```

### `version`

The `version` file should contain a single line with two fields. The first field should contain the software's upstream version and the second field should contain the version number of the KISS build files themselves.

**Example `version` file.**

```
1.2.3 1
```

### `checksums`

The `checksums` file is **generated by the package manager** and contains the `sha256sum` of all remote and local sources. This ensures most of all that the source you download matches the source the KISS developers used to build and install the software.

When creating a "KISS" package, `kiss checksum pkg` will download the remote sources and generate the `checksums` file. This command can then be run again to update the checksums in the case of a package update.

**Example `checksums` file.**

```
0e4925392fd9f3743cc517e031b68b012b24a63b0cf6c1ff03cce7bb3846cc99  busybox-1.31.0.tar.bz2
e942bc7e2274e15136a964bb3628b21fab3460327f3c7eb097e02f5faaaee93b  .config
6c3eb5cf839c7a31c337df0cd8388b397e1415ffa7a63e9678552c9c63dd869f  acpid.run
814dea14ac612125e97dcc1d619219b2c9dfc14850bf48d858421fb2c98eca12  crond.run
4a5981f4b0d791fe9b84b0b2e01ae905f6565c8245b3cd603e6decf34ddad71a  syslogd.run
f222991a00d8b30f1aaee5991bb9a8b624023e4a38cef46a1eddf2c8a55cfd3d  busybox.conf
```

### `manifest`

The `manifest` file is **generated by the package manager** and contains the full list of tracked files and directories. The package manager uses this file to install packages, remove packages, detect package conflicts and to detect library dependencies.

Files are listed first with directories following in reverse order. This allows the package removal process to easily remove empty directories as it starts with the deepest files and traverses upwards.

**Example `manifest` file.**

```
/var/db/kiss/installed/zlib/version
/var/db/kiss/installed/zlib/sources
/var/db/kiss/installed/zlib/manifest
/var/db/kiss/installed/zlib/depends
/var/db/kiss/installed/zlib/checksums
/var/db/kiss/installed/zlib/build
/var/db/kiss/installed/zlib/
/var/db/kiss/installed/
/var/db/kiss/
/var/db/
/var/
/usr/share/man/man3/zlib.3
/usr/share/man/man3/
/usr/share/man/
/usr/share/
/usr/lib/pkgconfig/zlib.pc
/usr/lib/pkgconfig/
/usr/lib/libz.so.1.2.11
/usr/lib/libz.so.1
/usr/lib/libz.so
/usr/lib/libz.a
/usr/lib/
/usr/include/zlib.h
/usr/include/zconf.h
/usr/include/
/usr/
```

### `post-install`

The `post-install` file should contain anything that needs to be run **after** a package installation to properly setup the software.

The script is language agnostic and the only requirement is that it be executable.

**Example `post-install` file.**

```
#!/bin/sh -e

/usr/sbin/update-ca-certificates --fresh
```

### `nostrip`

The `nostrip` file is an empty file which is used to tell the package manager to **not** strip the compiled package files of debug symbols etc. The only requirement is that this file exist, it doesn't need to contain any information.

### `patches/*`

The patches directory should contain any patches the software needs. In the `sources` file you refer to patches by using a relative path (`patches/musl.patch`).

The package manager **does not** automatically apply patches. This must be done in the `build` script of the package. The build script has direct access to the patches in its current working directory.

**Example `build` file with patches.**

```
#!/bin/sh -e

patch -p1 < rxvt-unicode-kerning.patch
patch -p1 < gentables.patch

./configure \
    --prefix=/usr \
    --with-terminfo=/usr/share/terminfo \
    --enable-256-color \
    --enable-font-styles \
    --enable-xim \
    --enable-keepscrolling \
    --enable-selectionscrolling \
    --enable-smart-resize \
    --enable-transparency \
    --enable-frills \
    --enable-perl \
    --enable-mousewheel \
    --enable-text-blink \
    --enable-fading \
    --enable-unicode3 \
    --disable-utmp \
    --disable-wtmp \
    --disable-lastlog

make DESTDIR="$1" install
```

### `files/*`

The `files/` directory should contain any miscellaneous files the software needs. In the `sources` file you refer to files by using a relative path (`files/busybox.config`).

The build script has direct access to the files in its current working directory.

**Example `build` file with files.**

```
#!/bin/sh -e

install -D kiss "$1/usr/bin/kiss"

# 'kiss_path.sh' is stored in 'files/kiss_path.sh'.
# The build script has direct access to it and it is
# added to the final tarball under /etc/profile.d/kiss_path.sh.
install -D kiss_path.sh "$1/etc/profile.d/kiss_path.sh"
```

## Package Manager

The package manager is tiny and written in 500~ lines (*excluding blank lines and comments*) of POSIX `sh`. The package manager is also linted with `shellcheck` and passes.

```
➜ kiss
=> kiss [b|c|i|l|r|s|u] [pkg] [pkg] [pkg].
=> build:     Build a package.
=> checksum:  Generate checksums.
=> install:   Install a package.
=> list:      List installed packages.
=> remove:    Remove a package.
=> search:    Search for a package.
=> update:    Check for updates.
```


## Further Reading

- [Frequently Asked Questions](https://getkiss.org/pages/faq/)
- [KISS on GitHub](https://github.com/kisslinux/)

If you have any questions feel free to get in touch.

- IRC: `#kisslinux` on Freenode.
- [Discord](https://discord.gg/YRwnHgH)
