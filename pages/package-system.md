---
title: Package System
category: main
---

The package system that KISS employs is a new concept that came to me (*Dylan Araps*) in a dream one night. The concept is simple; a set of plain text files separated by lines and spaces. Easily parseable in any programming language or with standard tools.


## Index

<!-- vim-markdown-toc GFM -->

* [The structure](#the-structure)
* [Benefits of this system](#benefits-of-this-system)
* [Installation](#installation)
* [Build](#build)
* [Dependencies](#dependencies)
* [Sources](#sources)
* [Version](#version)
* [Post Install](#post-install)

<!-- vim-markdown-toc -->


## The structure

```sh
zlib/            # Package name.
├─ build         # Build script.
├─ depends       # Dependencies (one per line) (sometimes optional).
├─ sources       # Sources (one per line).
├─ version       # Package version.
┘

# Files generated by the package manager.
├─ checksums     # The checksums for the source files.
┘

# Optional files.
├─ post-install  # Script to run after package installation.
├─ patches/*     # Directory to store patches.
├─ files/*       # Directory to misc files.
├─ nostrip       # Don't strip binaries for this package (empty file).
┘
```

## Benefits of this system

- No need to `source` (`eval`!!) the build script into the package manager.

All package managers and build tools which utilize a file full of arrays and functions (*a shell script*) to handle package information `source` this file. This is exactly the same as executing `eval` which is unknown to most.

In KISS the build script is executed as if it were any other executable file, essentially just a `./build`.


- Build scripts are language agnostic.

The above benefit also allows build scripts to be written in whatever programming language you see fit!


- Metadata files are simple to parse in any language.

The metadata files are separated by lines and spaces and can easily be parsed using whatever language or tools you wish.


- The repository files double as an installed package's database entry.

This is further explained directly below. One cool aspect of this however is the fact that your local installed package database doubles as a local package repository!

The package manager will interface with it when no matching packages are found in a repository. This allows you to rebuild packages which exist in no repository but are installed on your machine for example.


## Installation

When a package is installed, this entire directory tree is copied to `/var/db/kiss` where it becomes a database entry. Listing the dependencies for a package is a simple as printing the contents of the `depends` file. Searching for which package owns a file is as simple as checking each `manifest` file.

## Build

The `build` file should contain all of the steps required to patch, configure, build and install the package. The file should also be executable.

The current directory of the script is the source directory of the package, there is no need to `cd` anywhere. The script is passed a single argument which points to the directory the package should be installed to (`make DESTDIR="$1" install`).

**Simple example**:

```
#!/bin/sh -e

./configure \
    --prefix=/usr \
    --sysconfdir=/etc

make
make DESTDIR="$1" install
```

## Dependencies

The `depends`file should contain the package's dependencies one per line. A second column on each line is available to specify whether the dependency is needed only to build the package or if it is also required at runtime.

Comments are also supported using `#` at the start of the line. This allows simple package configuration through commented dependencies.

**Simple example**:

```
autoconf make
curl
libressl make
perl
zlib     make
```

## Sources

The `sources` file should contain all remote and local source files required during the build process, one per line. A second column on each line is available to specify the extraction directory or location in which a source should be available.

For example; this is used in `gcc`'s package to extract the source to a subdirectory called `gcc`.

**Simple example**:

```
https://gcc.gnu.org/pub/gcc/releases/gcc-9.1.0/gcc-9.1.0.tar.xz gcc
https://gmplib.org/download/gmp/gmp-6.1.2.tar.xz gcc/gmp
http://www.mpfr.org/mpfr-4.0.2/mpfr-4.0.2.tar.xz gcc/mpfr
https://ftp.gnu.org/gnu/mpc/mpc-1.1.0.tar.gz gcc/mpc
files/c99
```

## Version

The `version` file should contain a single line and two columns. The first column is the upstream package's version and the second column is the version of the actually repository files.

When a new version of a package is released, the first field is updated. When an update to the repository files is released the second field is updated.

**Simple example**:

```
3.2.1 1
```

## Post Install

The `post-install` file should contain any code that needs to be run after the installation of a package. This file should be executable. This file can be written in any programming language.

**Simple example**:

```
#!/bin/sh -e

/usr/sbin/update-ca-certificates --fresh
```
